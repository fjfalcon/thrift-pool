package com.qiwi.thrift.utils;

import org.apache.thrift.TApplicationException;
import org.apache.thrift.TException;
import org.apache.thrift.protocol.TProtocolException;
import org.apache.thrift.protocol.TSimpleJSONProtocol;
import org.apache.thrift.transport.TSaslTransportException;
import org.apache.thrift.transport.TTransportException;

import java.net.InetAddress;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Stream;

public class ThriftUtils {
    public static final String QIWI_APP_HOST_NAME = "qiwi.app.host.name";

    public static Class<?> getClassByName(Class<?> root, String name){
        Class<?>[] classes = root.getClasses();
        return Arrays.stream(classes)
                .filter(clazz -> name.equals(clazz.getSimpleName()))
                .findAny()
                .orElseThrow(() -> new IllegalArgumentException("Class with name " + name + " not found in " + root.getName()));
    }


    public static Class<?> getThriftRootClass(Class<?> generatedChildClass) {
        Class<?> clazz = generatedChildClass.getDeclaringClass();
        if (clazz == null){
            clazz = generatedChildClass;
        }

        try {
            getClassByName(clazz, "Iface");
        } catch (Exception ex) {
            throw new ThriftRuntimeException(
                    "Class was not generated by thrift compiler " + generatedChildClass.getName(),
                    ex
            );
        }
        return clazz;
    }

    public static boolean parseBoolean(String val) throws NumberFormatException{
        if ("true".equalsIgnoreCase(val) || "yes".equalsIgnoreCase(val) || "on".equalsIgnoreCase(val)) {
            return true;
        } else if ("false".equalsIgnoreCase(val) || "no".equalsIgnoreCase(val) || "off".equalsIgnoreCase(val)) {
            return false;
        } else {
            throw new NumberFormatException("Unable to parse boolean value: " + val);
        }

    }

    public static String getThriftServiceName(Class<?> generatedChildClass, Optional<String> subServiceName){
        Class<?> clazz = getThriftRootClass(generatedChildClass);
        if (subServiceName.isPresent()) {
            // double underscore to add ability parse full service name in class name and subservience name
            return clazz.getSimpleName() + "__" + subServiceName.get();
        } else {
            return clazz.getSimpleName();
        }
    }

    public static String getThriftServiceName(Class<?> generatedChildClass){
        return getThriftServiceName(generatedChildClass, Optional.empty());
    }

    public static String getThriftFullServiceName(Class<?> generatedChildClass, Optional<String> subServiceName){
        Class<?> clazz = getThriftRootClass(generatedChildClass);
        String name = clazz.getName().replace('.', '_');
        if (subServiceName.isPresent()) {
            // double underscore to add ability parse full service name in class name and subservience name
            return name + "__" + subServiceName.get();
        } else {
            return name;
        }
    }

    public static String getThriftFullServiceName(Class<?> generatedChildClass) {
        return getThriftFullServiceName(generatedChildClass, Optional.empty());
    }


    private static final Set<Class<? extends Throwable>> THRIFT_EXCEPTION_CLASSES = Collections.unmodifiableSet(
            new HashSet<>(Arrays.asList(
                    TException.class,
                    TSimpleJSONProtocol.CollectionMapKeyException.class,
                    TApplicationException.class,
                    TProtocolException.class,
                    TSaslTransportException.class,
                    TTransportException.class,
                    TTimeoutException.class
    )));

    public static boolean isApplicationLevelException(Throwable ex) {
        if (ex instanceof TException) {
            return !THRIFT_EXCEPTION_CLASSES.contains(ex.getClass());
        }
        if (ex instanceof ThriftApplicationException) {
            return true;
        }
        return false;
    }

    public static String getHostName(){
        String propHostName = System.getProperty(QIWI_APP_HOST_NAME);
        if (!empty(propHostName)) {
            return propHostName;
        } else {
            try {
                String hostName = InetAddress.getLocalHost().getCanonicalHostName();
                if (empty(hostName)) {
                    throw new ThriftRuntimeException("Unable to resolve current host name");
                }
                return hostName;
            } catch (Exception e) {
                throw new ThriftRuntimeException("Unable to resolve current host name", e);
            }
        }
    }


    /**
     *
     * @param futures futures to join
     * @param <T>
     * @return Future with result of first success future.
     *         If all futures complete exceptionally result future also complete exceptionally
     * @throws NoSuchElementException if stream is empty
     */
    public static <T> CompletableFuture<T> firstSuccess(Stream<CompletableFuture<T>> futures) throws NoSuchElementException{
        CompletableFuture<T> result = new CompletableFuture<>();
        CompletableFuture<Void>[] array = futures
                .map(future -> future.thenAccept(result::complete))
                .toArray(CompletableFuture[]::new);
        if (array.length == 0) {
            throw new NoSuchElementException("No result available.");
        }
        CompletableFuture.allOf(array).exceptionally(ex -> {
            result.completeExceptionally(ex);
            return null;
        });
        return result;
    }

    public static boolean empty(String str) {
        return str == null || str.isEmpty() || str.trim().isEmpty();
    }

    public static long parseLong(byte[] bytes){
        return      ((bytes[ 7] & 0xFFL) << 56)
                  | ((bytes[ 6] & 0xFFL) << 48)
                  | ((bytes[ 5] & 0xFFL) << 40)
                  | ((bytes[ 4] & 0xFFL) << 32)
                  | ((bytes[ 3] & 0xFFL) << 24)
                  | ((bytes[ 2] & 0xFFL) << 16)
                  | ((bytes[ 1] & 0xFFL) << 8)
                  | ((bytes[ 0] & 0xFFL));
    }

    public static long parseLong(byte[] bytes, int offset){
        return      ((bytes[ 7 + offset] & 0xFFL) << 56)
                  | ((bytes[ 6 + offset] & 0xFFL) << 48)
                  | ((bytes[ 5 + offset] & 0xFFL) << 40)
                  | ((bytes[ 4 + offset] & 0xFFL) << 32)
                  | ((bytes[ 3 + offset] & 0xFFL) << 24)
                  | ((bytes[ 2 + offset] & 0xFFL) << 16)
                  | ((bytes[ 1 + offset] & 0xFFL) << 8)
                  | ((bytes[ 0 + offset] & 0xFFL));
    }
}
